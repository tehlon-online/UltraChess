<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }

        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 80px);
            grid-template-rows: repeat(8, 80px);
            gap: 0;
            border: 2px solid #333;
        }

        .square {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: bold;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .white-piece {
            color: #d9d9d9;
            text-shadow: 1px 1px 2px #000000;
        }

        .black-piece {
            color: #333333;
        }

        #player-turn {
            margin-top: 20px;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="chessboard"></div>
    <div id="player-turn">White's Turn</div>
    <script>
        const chessboard = document.getElementById('chessboard');
        const playerTurn = document.getElementById('player-turn');
        let turn = 'white';

        const pieces = {
            // White Pieces
            '0,0': '♖', '1,0': '♘', '2,0': '♗', '3,0': '♕', '4,0': '♔', '5,0': '♗', '6,0': '♘', '7,0': '♖',
            '0,1': '♙', '1,1': '♙', '2,1': '♙', '3,1': '♙', '4,1': '♙', '5,1': '♙', '6,1': '♙', '7,1': '♙',
            // Black Pieces
            '0,6': '♟', '1,6': '♟', '2,6': '♟', '3,6': '♟', '4,6': '♟', '5,6': '♟', '6,6': '♟', '7,6': '♟',
            '0,7': '♜', '1,7': '♞', '2,7': '♝', '3,7': '♛', '4,7': '♚', '5,7': '♝', '6,7': '♞', '7,7': '♜'
        };

        // Initialize chessboard
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const square = document.createElement('div');
                square.classList.add('square', (row + col) % 2 === 0 ? 'light' : 'dark');
                square.id = `${col},${row}`;
                if (pieces[`${col},${row}`]) {
                    square.textContent = pieces[`${col},${row}`];
                    if (row < 2) {
                        square.classList.add('white-piece');
                    } else {
                        square.classList.add('black-piece');
                    }
                    square.draggable = true;
                }
                chessboard.appendChild(square);
            }
        }

        // Drag and Drop Functionality
        let draggedPiece = null;
        let startPosition = null;

        chessboard.addEventListener('dragstart', (e) => {
            const pieceColor = e.target.classList.contains('white-piece') ? 'white' : 'black';
            if (pieceColor !== turn) {
                e.preventDefault();
                return;
            }
            draggedPiece = e.target;
            startPosition = e.target.id;
            e.dataTransfer.setData('text/plain', e.target.id);
        });

        chessboard.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        chessboard.addEventListener('drop', (e) => {
            e.preventDefault();
            const targetSquare = e.target;

            // Ensure the move is valid (basic validation for now)
            const [startX, startY] = startPosition.split(',').map(Number);
            const [endX, endY] = targetSquare.id.split(',').map(Number);

            if (isValidMove(startX, startY, endX, endY, draggedPiece.textContent)) {
                const pieceClass = draggedPiece.classList.contains('white-piece') ? 'white-piece' : 'black-piece';
                targetSquare.textContent = draggedPiece.textContent;
                targetSquare.classList.add(pieceClass);
                targetSquare.classList.remove(pieceClass === 'white-piece' ? 'black-piece' : 'white-piece');
                draggedPiece.textContent = '';
                draggedPiece.draggable = false;
                targetSquare.draggable = true;

                // Switch turn
                turn = turn === 'white' ? 'black' : 'white';
                playerTurn.textContent = `${turn.charAt(0).toUpperCase() + turn.slice(1)}'s Turn`;
            }
        });

        // Basic move validation function
        function isValidMove(startX, startY, endX, endY, piece) {
            // Implement basic move validation based on piece type
            switch (piece) {
                case '♙': // White pawn
                case '♟': // Black pawn
                    return isValidPawnMove(startX, startY, endX, endY, piece);
                case '♖': // Rook
                case '♜':
                    return isValidRookMove(startX, startY, endX, endY);
                case '♘': // Knight
                case '♞':
                    return isValidKnightMove(startX, startY, endX, endY);
                case '♗': // Bishop
                case '♝':
                    return isValidBishopMove(startX, startY, endX, endY);
                case '♕': // Queen
                case '♛':
                    return isValidQueenMove(startX, startY, endX, endY);
                case '♔': // King
                case '♚':
                    return isValidKingMove(startX, startY, endX, endY);
                default:
                    return false;
            }
        }

        function isValidPawnMove(startX, startY, endX, endY, piece) {
            const direction = piece === '♙' ? 1 : -1;
            const startRow = piece === '♙' ? 1 : 6;
            const opponentPieceClass = piece === '♙' ? 'black-piece' : 'white-piece';

            // Move forward
            if (startX === endX) {
                // Single step forward
                if (startY + direction === endY && !document.getElementById(`${endX},${endY}`).textContent) return true;
                // Double step forward from starting position
                if (startY === startRow && startY + 2 * direction === endY && !document.getElementById(`${endX},${startY + direction}`).textContent && !document.getElementById(`${endX},${endY}`).textContent) return true;
            }
            // Capture diagonally
            else if (Math.abs(startX - endX) === 1 && startY + direction === endY) {
                if (document.getElementById(`${endX},${endY}`).classList.contains(opponentPieceClass)) return true;
            }
            return false;
        }

        function isValidRookMove(startX, startY, endX, endY) {
            return startX === endX || startY === endY;
        }

        function isValidKnightMove(startX, startY, endX, endY) {
            return (Math.abs(startX - endX) === 1 && Math.abs(startY - endY) === 2) ||
                   (Math.abs(startX - endX) === 2 && Math.abs(startY - endY) === 1);
        }

        function isValidBishopMove(startX, startY, endX, endY) {
            return Math.abs(startX - endX) === Math.abs(startY - endY);
        }

        function isValidQueenMove(startX, startY, endX, endY) {
            return isValidRookMove(startX, startY, endX, endY) ||
                   isValidBishopMove(startX, startY, endX, endY);
        }

        function isValidKingMove(startX, startY, endX, endY) {
            return Math.abs(startX - endX) <= 1 && Math.abs(startY - endY) <= 1;
        }
    </script>
</body>
</html>